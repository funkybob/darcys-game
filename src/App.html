<main>
  <h1> Score: {score} </h1>
  <button on:click="startGame()" disabled={running}>Start Game</button>
  <h2> Level: {level+1} </h2>
</main>
<p> Instructions: When a moving shape appears, click-and-hold on the matching shape on the border, and join the red line to the moving shape. </p>
<svg ref:canvas viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"
  on:mousemove="trackMouse(event)"
  on:mouseup="mouseup(null)"
>
  <circle cx="100" cy="100" r="80" fill="green" stroke="black" />
  {#each starts as shape (shape.id)}
    <Shape n={shape.n} x={shape.x} y={shape.y} fill={shape.fill}
        on:mousedown="mousedown(shape)"
    />
  {/each}
  {#each shapes as shape (shape.id)}
    <Shape n={shape.n} x={shape.x} y={shape.y} fill={shape.fill}
        on:mouseup="mouseup(shape)"
    />
  {/each}
  {#if down}
  <line stroke="red" x1={down.x + 10} y1={down.y + 10} x2={pointer.x} y2={pointer.y} />
  {/if}
</svg>

<script>
  import Shape from './Shape.html'

  const colours = [
    'red',
    'orange',
    'yellow',
    'lightgreen',
    'blue',
    'purple',
    'coral',
  ]

  export default {
    components: {
      Shape,
    },
    data () {
      return {
        running: false,
        // ID sequence for shapes
        counter: 0,
        score: 0,
        starts: [],
        shapes: [],
        now: 0,
        // Time the game started
        start: undefined,
        lastSpawn: 0,
        level: 0,
        // Where the mouse-down started
        down: undefined,
        pointer: undefined
      }
    },
    computed: {
      frame: ({start, now}) => Math.floor((now - start) / 60),
      level: ({score}) => {
        let step = 20;
        let level = 0;
        score -= step;
        while(score > 0) { level += 1; score -= step; step *= 1.2; }
        return level
      },
      interval: ({level}) => Math.floor(85 - level * Math.log(level+1)) // Caps us about level 50
    },
    oncreate () {
      this.pt = this.refs.canvas.createSVGPoint()
      this.on('update', ({ changed, current, previous }) => {
        if (!previous) {
          // first update
        } else {
          if (current.frame > previous.frame) {
            if(current.frame - current.lastSpawn > current.interval) {
              this.addShape()
            }
          }
          if (current.level > previous.level) {
            this.nextLevel()
          }
        }
      })
    },
    methods: {
      startGame () {
        this.set({
          running: true,
          start: performance.now(),
          score: 0,
          lastSpawn: 0,
          shapes: [],
          starts: []
        })
        this.nextLevel();
        this.onTimer()
      },
      onTimer (now) {
        this.set({now})
        this.travelShapes();
        if (this.get().running)
          window.requestAnimationFrame(this.onTimer.bind(this))
      },
      nextLevel () {
        let {starts, level, counter} = this.get()
        let shape = {
          id: counter,
          fill: colours[level % colours.length],
          x: 0,
          y: 0,
          n: 3 + level,
        }
        starts.push(shape)
        counter += 1;
        // Re-distribute around the circle
        const arc = 360 / starts.length;
        for(let i=0, l=starts.length; i < l; i++) {
          let a = arc * i + 90;
          // centre of circle is 100,100
          // shape is 20x20, so offset -10,-10
          // circle has radius of 80, so place these a bit wider
          starts[i].x = 90 + 90 * Math.cos(a * Math.PI / 180)
          starts[i].y = 90 + 90 * Math.sin(a * Math.PI / 180)
        }
        this.set({starts, counter})
      },
      addShape () {
        let {level, frame, shapes, counter} = this.get()
        // level is 0-based
        let n = Math.round(Math.random() * level)
        let shape = {
          id: counter,
          frame: frame,
          fill: colours[n % colours.length],
          x: 90,
          y: 90,
          n: 3 + n,
          v: Math.floor(Math.random() * 360)
        }
        shapes.push(shape)
        counter += 1;
        this.set({shapes, counter, lastSpawn: frame})
      },
      travelShapes () {
        // Move each shape along according to its vector 'v'
        let {frame, shapes} = this.get()
        shapes.forEach(shape => {
          let age = frame - shape.frame
          if (age == 80) this.endGame()
          // centre of circle is 100,100
          // shape is 20x20, so offset -10,-10
          shape.x = 90 + age * Math.cos(shape.v * Math.PI / 180)
          shape.y = 90 + age * Math.sin(shape.v * Math.PI / 180)
        })
        this.set({shapes})
      },
      endGame () {
        this.set({running: false})
        alert("GAME OVER!")
      },
      trackMouse (ev) {
        this.pt.x = ev.clientX;
        this.pt.y = ev.clientY;
        let p = this.pt.matrixTransform(this.refs.canvas.getScreenCTM().inverse())
        let pointer = {x: p.x, y: p.y}
        this.set({pointer})
      },
      mousedown (shape) {
        this.set({down: shape})
      },
      mouseup (shape) {
        let {score, down, shapes} = this.get()
        this.set({down: undefined})
        if (shape === null) {
          return;
        }
        if (down.n == shape.n) {
          score += shape.n
          shapes = shapes.filter(s => s.id !== shape.id)
          this.set({score, shapes})
        }
      }
    }
  }
</script>

<style>
  main { display: flex; flex-wrap: wrap; }
  h1, h2 { flex: 2 2 auto; text-align: center; }
  button { flex: 1 1 auto; }
  svg {
    width: 80vh;
    height: 80vh;
    margin: 0 auto;
    display: block;
  }
  line { pointer-events: none; }
</style>
